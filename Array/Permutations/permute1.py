#!/usr/bin/python

"""
Permutations 

Given a collection of numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
"""

class Solution:
    # @param num, a list of integer
    # @return a list of lists of integers
    def permute(self, num):
        result = []
        self.getPerm(num,0,len(num)-1,result)
        return result

    def getPerm(self, num, k, n, result):
        if k == n: result.append(list(num))
        else:
            for i in xrange(k,n+1):
                num[k],num[i] = num[i],num[k]
                self.getPerm(num,k+1,n,result)
                num[k],num[i] = num[i],num[k]

if __name__=="__main__":
    s = [1,2,3] 
    print Solution().permute(s)

"""
The idea of this classic problem is to use backtracking.
We want to get permutations, which is mainly about swap values in the list.
Consider:
a --> a
ab --> ab, ba
abc --> abc, acb, bac, bca, cab, cba.
...
where for the length of n, the permutations can be generated by
(1) Swap the 1st element with all the elements, including itself.
(2) Then the 1st element is fixed, go to the next element.
(3) Until the last element is fixed. Output.

The key point is to make the big problem into smaller problem, 
here is how to convert the length n permutation into length n-1 
permutation problem.
"""